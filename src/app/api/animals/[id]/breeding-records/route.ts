// app/api/animals/[id]/breeding-records/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase/server'

interface RouteParams {
  params: Promise<{ id: string }>
}

export async function GET(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const supabase = await createServerSupabaseClient()
    const { id: animalId } = await params

    console.log('üìã [BREEDING-API] Fetching breeding records for animal:', animalId)

    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
    if (!animalId || !uuidRegex.test(animalId)) {
      return NextResponse.json(
        { success: false, error: 'Invalid animal ID format' },
        { status: 400 }
      )
    }

    // Get breeding records for this animal
    const { data: breedingRecords, error: recordsError } = await supabase
      .from('breeding_records')
      .select('*')
      .eq('animal_id', animalId)
      .order('breeding_date', { ascending: false })

    if (recordsError) {
      console.error('‚ùå [BREEDING-API] Error fetching breeding records:', recordsError)
      throw recordsError
    }

    console.log('‚úÖ [BREEDING-API] Found breeding records:', breedingRecords?.length || 0)

    // Get pregnancy records for these breeding records
    const breedingRecordIds = breedingRecords?.map(r => r.id) || []
    
    let pregnancyRecords: any[] = []
    if (breedingRecordIds.length > 0) {
      const { data: pregnancyData, error: pregnancyError } = await supabase
        .from('pregnancy_records')
        .select('*')
        .in('breeding_record_id', breedingRecordIds)
        .order('created_at', { ascending: false })

      if (pregnancyError) {
        console.error('‚ö†Ô∏è [BREEDING-API] Error fetching pregnancy records:', pregnancyError)
      } else {
        pregnancyRecords = pregnancyData || []
        console.log('‚úÖ [BREEDING-API] Found pregnancy records:', pregnancyRecords.length)
      }
    }

    // Transform data to match component expectations
    const transformedRecords = (breedingRecords || []).map(record => {
      const pregnancyRecord = pregnancyRecords.find(p => p.breeding_record_id === record.id)
      
      // Determine if auto-generated based on notes
      const isAutoGenerated = record.notes?.includes('ü§ñ Auto-generated') || false
      
      // Map pregnancy status from DB to component format
      const pregnancyStatus = mapPregnancyStatus(pregnancyRecord?.pregnancy_status)
      
      return {
        id: record.id,
        animal_id: record.animal_id,
        breeding_date: record.breeding_date,
        breeding_method: record.breeding_type, // Map breeding_type to breeding_method
        sire_tag: record.sire_name || record.sire_id,
        sire_breed: record.sire_breed,
        expected_calving_date: pregnancyRecord?.expected_calving_date,
        actual_calving_date: pregnancyRecord?.actual_calving_date,
        pregnancy_confirmed: pregnancyRecord?.pregnancy_status === 'confirmed',
        pregnancy_check_date: pregnancyRecord?.confirmed_date,
        pregnancy_status: pregnancyStatus,
        gestation_period: pregnancyRecord?.gestation_length || 280,
        breeding_notes: record.notes,
        veterinarian: record.technician_name,
        breeding_cost: record.cost,
        created_at: record.created_at,
        updated_at: record.updated_at,
        auto_generated: isAutoGenerated
      }
    })

    // Also return transformed pregnancy checks for compatibility
    const transformedPregnancyChecks = pregnancyRecords.map(pr => ({
      id: pr.id,
      breeding_record_id: pr.breeding_record_id,
      check_date: pr.confirmed_date || pr.created_at?.split('T')[0],
      check_method: pr.confirmation_method || 'visual',
      result: mapPregnancyStatusToResult(pr.pregnancy_status),
      checked_by: pr.veterinarian || 'Auto-generated',
      notes: pr.pregnancy_notes,
      next_check_date: null
    }))

    return NextResponse.json({
      success: true,
      breedingRecords: transformedRecords,
      pregnancyChecks: transformedPregnancyChecks
    })
  } catch (error: any) {
    console.error('‚ùå [BREEDING-API] Error in GET breeding records:', error)
    return NextResponse.json(
      { success: false, error: error.message || 'Failed to fetch breeding records' },
      { status: 500 }
    )
  }
}

export async function POST(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const supabase = await createServerSupabaseClient()
    const { id: animalId } = await params
    const body = await request.json()

    console.log('üìù [BREEDING-API] Creating breeding record for animal:', animalId)

    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
    if (!animalId || !uuidRegex.test(animalId)) {
      return NextResponse.json(
        { success: false, error: 'Invalid animal ID format' },
        { status: 400 }
      )
    }

    const {
      breeding_date,
      breeding_method,
      sire_tag,
      sire_breed,
      veterinarian,
      breeding_cost,
      breeding_notes,
      gestation_period = 280,
      auto_generated = false
    } = body

    // Validate required fields
    if (!breeding_date || !breeding_method) {
      return NextResponse.json(
        { success: false, error: 'Breeding date and method are required' },
        { status: 400 }
      )
    }

    // Get farm_id from animal
    const { data: animal, error: animalError } = await supabase
      .from('animals')
      .select('farm_id')
      .eq('id', animalId)
      .single()

    if (animalError) {
      console.error('‚ùå [BREEDING-API] Error fetching animal:', animalError)
      throw animalError
    }

    // Calculate expected calving date
    const breedingDateObj = new Date(breeding_date)
    const expectedCalvingDate = new Date(breedingDateObj)
    expectedCalvingDate.setDate(expectedCalvingDate.getDate() + gestation_period)
    const expectedCalvingDateStr = expectedCalvingDate.toISOString().split('T')[0]

    // Insert breeding record
    const { data: breedingRecord, error: insertError } = await supabase
      .from('breeding_records')
      .insert({
        animal_id: animalId,
        farm_id: animal.farm_id,
        breeding_type: breeding_method,
        breeding_date,
        sire_name: sire_tag || null,
        sire_breed: sire_breed || null,
        technician_name: veterinarian || null,
        cost: breeding_cost ? parseFloat(breeding_cost) : null,
        notes: breeding_notes || null
      })
      .select()
      .single()

    if (insertError) {
      console.error('‚ùå [BREEDING-API] Error inserting breeding record:', insertError)
      throw insertError
    }

    console.log('‚úÖ [BREEDING-API] Created breeding record:', breedingRecord.id)

    // Determine pregnancy status based on body
    const pregnancyStatus = body.pregnancy_status ? 
      mapComponentStatusToDb(body.pregnancy_status) : 'suspected'

    // Create pregnancy record
    const pregnancyData: any = {
      breeding_record_id: breedingRecord.id,
      animal_id: animalId,
      farm_id: animal.farm_id,
      pregnancy_status: pregnancyStatus,
      expected_calving_date: body.expected_calving_date || expectedCalvingDateStr,
      gestation_length: gestation_period
    }

    // Add optional pregnancy fields if provided
    if (body.pregnancy_confirmed) {
      pregnancyData.confirmation_method = 'rectal_palpation'
      pregnancyData.confirmed_date = body.pregnancy_check_date || breeding_date
    }

    if (body.actual_calving_date) {
      pregnancyData.actual_calving_date = body.actual_calving_date
    }

    if (breeding_notes) {
      pregnancyData.pregnancy_notes = breeding_notes
    }

    const { data: pregnancyRecord, error: pregnancyError } = await supabase
      .from('pregnancy_records')
      .insert(pregnancyData)
      .select()
      .single()

    if (pregnancyError) {
      console.error('‚ùå [BREEDING-API] Error inserting pregnancy record:', pregnancyError)
      throw pregnancyError
    }

    console.log('‚úÖ [BREEDING-API] Created pregnancy record:', pregnancyRecord.id)

    // Update animal production status to 'served' if not already pregnant/dry
    const { error: updateError } = await supabase
      .from('animals')
      .update({ 
        production_status: 'served',
        updated_at: new Date().toISOString()
      })
      .eq('id', animalId)

    if (updateError) {
      console.error('‚ö†Ô∏è [BREEDING-API] Error updating animal status:', updateError)
      // Don't throw - record is created, just log the error
    } else {
      console.log('‚úÖ [BREEDING-API] Updated animal production status to "served"')
    }

    // Transform response to match expected format
    const transformedBreedingRecord = {
      id: breedingRecord.id,
      animal_id: breedingRecord.animal_id,
      breeding_date: breedingRecord.breeding_date,
      breeding_method: breedingRecord.breeding_type,
      sire_tag: breedingRecord.sire_name,
      sire_breed: breedingRecord.sire_breed,
      expected_calving_date: pregnancyRecord.expected_calving_date,
      actual_calving_date: pregnancyRecord.actual_calving_date,
      pregnancy_status: mapPregnancyStatus(pregnancyRecord.pregnancy_status),
      pregnancy_confirmed: pregnancyRecord.pregnancy_status === 'confirmed',
      pregnancy_check_date: pregnancyRecord.confirmed_date,
      breeding_notes: breedingRecord.notes,
      veterinarian: breedingRecord.technician_name,
      breeding_cost: breedingRecord.cost,
      gestation_period,
      created_at: breedingRecord.created_at,
      updated_at: breedingRecord.updated_at,
      auto_generated
    }

    return NextResponse.json({
      success: true,
      breedingRecord: transformedBreedingRecord,
      pregnancyRecord,
      message: 'Breeding record created successfully'
    })
  } catch (error: any) {
    console.error('‚ùå [BREEDING-API] Error in POST breeding record:', error)
    return NextResponse.json(
      { success: false, error: error.message || 'Failed to create breeding record' },
      { status: 500 }
    )
  }
}

// Helper function to map pregnancy_status from DB to component expectations
function mapPregnancyStatus(dbStatus: string | undefined): string {
  if (!dbStatus) return 'pending'
  
  switch (dbStatus) {
    case 'suspected':
      return 'pending'
    case 'confirmed':
      return 'confirmed'
    case 'false':
      return 'negative'
    case 'aborted':
      return 'aborted'
    case 'completed':
      return 'completed'
    default:
      return 'pending'
  }
}

// Helper function to map component status to DB format
function mapComponentStatusToDb(componentStatus: string): string {
  switch (componentStatus) {
    case 'pending':
      return 'suspected'
    case 'confirmed':
      return 'confirmed'
    case 'negative':
      return 'false'
    case 'aborted':
      return 'aborted'
    case 'completed':
      return 'completed'
    default:
      return 'suspected'
  }
}

// Helper function to map pregnancy_status to check result
function mapPregnancyStatusToResult(dbStatus: string | undefined): string {
  if (!dbStatus) return 'pending'
  
  switch (dbStatus) {
    case 'suspected':
      return 'inconclusive'
    case 'confirmed':
      return 'positive'
    case 'false':
      return 'negative'
    case 'aborted':
      return 'negative'
    case 'completed':
      return 'positive'
    default:
      return 'pending'
  }
}